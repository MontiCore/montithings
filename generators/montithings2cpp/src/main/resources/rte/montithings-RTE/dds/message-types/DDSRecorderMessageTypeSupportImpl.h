/* -*- C++ -*- */
/* Generated by /home/luke/Projects/OpenDDS/bin/opendds_idl version 3.15 (ACE version 6.2a_p19) running on input file /home/luke/Projects/montithings/core/generators/montithings2cpp/src/main/resources/rte/montithings-RTE/dds/message-types/DDSRecorderMessage.idl */
#ifndef OPENDDS_IDL_GENERATED_DDSRECORDERMESSAGETYPESUPPORTIMPL_H_FN6U46
#define OPENDDS_IDL_GENERATED_DDSRECORDERMESSAGETYPESUPPORTIMPL_H_FN6U46
#include "DDSRecorderMessageC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "DDSRecorderMessageTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/ValueWriter.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: DDSRecorderMessage */



/* Begin ENUM: MessageType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDSRecorderMessage::MessageType& enumval);

bool operator>>(Serializer& strm, DDSRecorderMessage::MessageType& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::MessageType& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDSRecorderMessage_MessageType_names[];
extern const size_t gen_DDSRecorderMessage_MessageType_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: MessageType */


/* Begin STRUCT: Message */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDSRecorderMessage::Message& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const DDSRecorderMessage::Message& stru);

bool operator>>(Serializer& strm, DDSRecorderMessage::Message& stru);

size_t gen_max_marshaled_size(const DDSRecorderMessage::Message& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const DDSRecorderMessage::Message> stru, bool align);

void gen_find_size(KeyOnly<const DDSRecorderMessage::Message> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const DDSRecorderMessage::Message> stru);

bool operator>>(Serializer& strm, KeyOnly<DDSRecorderMessage::Message> stru);

template <>
struct MarshalTraits<DDSRecorderMessage::Message> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
  static bool to_message_block(ACE_Message_Block&, const DDSRecorderMessage::Message&) { return false; }
  static bool from_message_block(DDSRecorderMessage::Message&, const ACE_Message_Block&) { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
/// This structure supports use of std::map with one or more keys.
struct  Message_OpenDDS_KeyLessThan {
  bool operator()(const DDSRecorderMessage::Message& v1, const DDSRecorderMessage::Message& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.id < v2.id) return true;
    if (v2.id < v1.id) return false;
    if (v1.instance_name < v2.instance_name) return true;
    if (v2.instance_name < v1.instance_name) return false;
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::Message& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class MessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDSRecorderMessage::Message> {
  typedef DDSRecorderMessage::Message MessageType;
  typedef DDSRecorderMessage::MessageSeq MessageSequenceType;
  typedef DDSRecorderMessage::MessageTypeSupport TypeSupportType;
  typedef DDSRecorderMessage::MessageTypeSupportImpl TypeSupportTypeImpl;
  typedef DDSRecorderMessage::MessageDataWriter DataWriterType;
  typedef DDSRecorderMessage::MessageDataReader DataReaderType;
  typedef DDSRecorderMessage::Message_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDSRecorderMessage::Message"; }
  static bool gen_has_key () { return true; }
  static size_t key_count () { return 2; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class  MessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<MessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<Message> TraitsType;
  typedef MessageTypeSupport TypeSupportType;
  typedef MessageTypeSupport::_var_type _var_type;
  typedef MessageTypeSupport::_ptr_type _ptr_type;

  MessageTypeSupportImpl() {}
  virtual ~MessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static MessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
const MetaStruct& getMetaStruct<DDSRecorderMessage::Message>();
bool gen_skip_over(Serializer& ser, DDSRecorderMessage::Message*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Message */


/* Begin ENUM: CommandType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDSRecorderMessage::CommandType& enumval);

bool operator>>(Serializer& strm, DDSRecorderMessage::CommandType& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::CommandType& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

extern const char* gen_DDSRecorderMessage_CommandType_names[];
extern const size_t gen_DDSRecorderMessage_CommandType_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: CommandType */


/* Begin STRUCT: Command */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDSRecorderMessage::Command& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const DDSRecorderMessage::Command& stru);

bool operator>>(Serializer& strm, DDSRecorderMessage::Command& stru);

size_t gen_max_marshaled_size(const DDSRecorderMessage::Command& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const DDSRecorderMessage::Command> stru, bool align);

void gen_find_size(KeyOnly<const DDSRecorderMessage::Command> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const DDSRecorderMessage::Command> stru);

bool operator>>(Serializer& strm, KeyOnly<DDSRecorderMessage::Command> stru);

template <>
struct MarshalTraits<DDSRecorderMessage::Command> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
  static bool to_message_block(ACE_Message_Block&, const DDSRecorderMessage::Command&) { return false; }
  static bool from_message_block(DDSRecorderMessage::Command&, const ACE_Message_Block&) { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
/// This structure supports use of std::map with one or more keys.
struct  Command_OpenDDS_KeyLessThan {
  bool operator()(const DDSRecorderMessage::Command& v1, const DDSRecorderMessage::Command& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.id < v2.id) return true;
    if (v2.id < v1.id) return false;
    if (v1.instance_name < v2.instance_name) return true;
    if (v2.instance_name < v1.instance_name) return false;
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::Command& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class CommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDSRecorderMessage::Command> {
  typedef DDSRecorderMessage::Command MessageType;
  typedef DDSRecorderMessage::CommandSeq MessageSequenceType;
  typedef DDSRecorderMessage::CommandTypeSupport TypeSupportType;
  typedef DDSRecorderMessage::CommandTypeSupportImpl TypeSupportTypeImpl;
  typedef DDSRecorderMessage::CommandDataWriter DataWriterType;
  typedef DDSRecorderMessage::CommandDataReader DataReaderType;
  typedef DDSRecorderMessage::Command_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDSRecorderMessage::Command"; }
  static bool gen_has_key () { return true; }
  static size_t key_count () { return 2; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class  CommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<Command> TraitsType;
  typedef CommandTypeSupport TypeSupportType;
  typedef CommandTypeSupport::_var_type _var_type;
  typedef CommandTypeSupport::_ptr_type _ptr_type;

  CommandTypeSupportImpl() {}
  virtual ~CommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<DDSRecorderMessage::Command>();
bool gen_skip_over(Serializer& ser, DDSRecorderMessage::Command*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Command */


/* Begin STRUCT: CommandReply */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDSRecorderMessage::CommandReply& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const DDSRecorderMessage::CommandReply& stru);

bool operator>>(Serializer& strm, DDSRecorderMessage::CommandReply& stru);

size_t gen_max_marshaled_size(const DDSRecorderMessage::CommandReply& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const DDSRecorderMessage::CommandReply> stru, bool align);

void gen_find_size(KeyOnly<const DDSRecorderMessage::CommandReply> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const DDSRecorderMessage::CommandReply> stru);

bool operator>>(Serializer& strm, KeyOnly<DDSRecorderMessage::CommandReply> stru);

template <>
struct MarshalTraits<DDSRecorderMessage::CommandReply> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
  static bool to_message_block(ACE_Message_Block&, const DDSRecorderMessage::CommandReply&) { return false; }
  static bool from_message_block(DDSRecorderMessage::CommandReply&, const ACE_Message_Block&) { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
/// This structure supports use of std::map with one or more keys.
struct  CommandReply_OpenDDS_KeyLessThan {
  bool operator()(const DDSRecorderMessage::CommandReply& v1, const DDSRecorderMessage::CommandReply& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.id < v2.id) return true;
    if (v2.id < v1.id) return false;
    if (v1.instance_name < v2.instance_name) return true;
    if (v2.instance_name < v1.instance_name) return false;
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::CommandReply& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class CommandReplyTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDSRecorderMessage::CommandReply> {
  typedef DDSRecorderMessage::CommandReply MessageType;
  typedef DDSRecorderMessage::CommandReplySeq MessageSequenceType;
  typedef DDSRecorderMessage::CommandReplyTypeSupport TypeSupportType;
  typedef DDSRecorderMessage::CommandReplyTypeSupportImpl TypeSupportTypeImpl;
  typedef DDSRecorderMessage::CommandReplyDataWriter DataWriterType;
  typedef DDSRecorderMessage::CommandReplyDataReader DataReaderType;
  typedef DDSRecorderMessage::CommandReply_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDSRecorderMessage::CommandReply"; }
  static bool gen_has_key () { return true; }
  static size_t key_count () { return 2; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class  CommandReplyTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CommandReplyTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CommandReply> TraitsType;
  typedef CommandReplyTypeSupport TypeSupportType;
  typedef CommandReplyTypeSupport::_var_type _var_type;
  typedef CommandReplyTypeSupport::_ptr_type _ptr_type;

  CommandReplyTypeSupportImpl() {}
  virtual ~CommandReplyTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CommandReplyTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<DDSRecorderMessage::CommandReply>();
bool gen_skip_over(Serializer& ser, DDSRecorderMessage::CommandReply*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CommandReply */


/* Begin STRUCT: Acknowledgement */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDSRecorderMessage::Acknowledgement& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const DDSRecorderMessage::Acknowledgement& stru);

bool operator>>(Serializer& strm, DDSRecorderMessage::Acknowledgement& stru);

size_t gen_max_marshaled_size(const DDSRecorderMessage::Acknowledgement& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const DDSRecorderMessage::Acknowledgement> stru, bool align);

void gen_find_size(KeyOnly<const DDSRecorderMessage::Acknowledgement> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const DDSRecorderMessage::Acknowledgement> stru);

bool operator>>(Serializer& strm, KeyOnly<DDSRecorderMessage::Acknowledgement> stru);

template <>
struct MarshalTraits<DDSRecorderMessage::Acknowledgement> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
  static bool to_message_block(ACE_Message_Block&, const DDSRecorderMessage::Acknowledgement&) { return false; }
  static bool from_message_block(DDSRecorderMessage::Acknowledgement&, const ACE_Message_Block&) { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
/// This structure supports use of std::map with one or more keys.
struct  Acknowledgement_OpenDDS_KeyLessThan {
  bool operator()(const DDSRecorderMessage::Acknowledgement& v1, const DDSRecorderMessage::Acknowledgement& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.id < v2.id) return true;
    if (v2.id < v1.id) return false;
    if (v1.sending_instance < v2.sending_instance) return true;
    if (v2.sending_instance < v1.sending_instance) return false;
    if (v1.receiving_instance < v2.receiving_instance) return true;
    if (v2.receiving_instance < v1.receiving_instance) return false;
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const DDSRecorderMessage::Acknowledgement& value);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class AcknowledgementTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDSRecorderMessage::Acknowledgement> {
  typedef DDSRecorderMessage::Acknowledgement MessageType;
  typedef DDSRecorderMessage::AcknowledgementSeq MessageSequenceType;
  typedef DDSRecorderMessage::AcknowledgementTypeSupport TypeSupportType;
  typedef DDSRecorderMessage::AcknowledgementTypeSupportImpl TypeSupportTypeImpl;
  typedef DDSRecorderMessage::AcknowledgementDataWriter DataWriterType;
  typedef DDSRecorderMessage::AcknowledgementDataReader DataReaderType;
  typedef DDSRecorderMessage::Acknowledgement_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDSRecorderMessage::Acknowledgement"; }
  static bool gen_has_key () { return true; }
  static size_t key_count () { return 3; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace DDSRecorderMessage {
class  AcknowledgementTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<AcknowledgementTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<Acknowledgement> TraitsType;
  typedef AcknowledgementTypeSupport TypeSupportType;
  typedef AcknowledgementTypeSupport::_var_type _var_type;
  typedef AcknowledgementTypeSupport::_ptr_type _ptr_type;

  AcknowledgementTypeSupportImpl() {}
  virtual ~AcknowledgementTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static AcknowledgementTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<DDSRecorderMessage::Acknowledgement>();
bool gen_skip_over(Serializer& ser, DDSRecorderMessage::Acknowledgement*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Acknowledgement */

/* End MODULE: DDSRecorderMessage */
#endif /* OPENDDS_IDL_GENERATED_DDSRECORDERMESSAGETYPESUPPORTIMPL_H_FN6U46 */
