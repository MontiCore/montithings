// (c) https://github.com/MontiCore/monticore
grammar MontiThings extends MontiArc {

    start MTCompilationUnit;

    /** 
     * ASTMTCompilationUnit represents the entire content of a MontiArc model artifact
     *
     * @attribute package          The package declaration of the component model
     * @attribute importStatements List of imported elements (data types and component types)
     * @attribute component The outermost component model defined in this compilation unit
     */
    MTCompilationUnit =
      ("package" package:(Name& || ".")+ ";")?  // optional package declaration
      (ImportStatement)*
      (ImportStatementLOCAL)*                   // import statements
      Component                                 // single outermost component declaration 
      EOF;                                      // and nothing (end of file) afterwards

    /**
     * Interface component has no implementation except Ports
     * TODO: extend MontiArc's Component instead of overwriting it - Needs MontiArc to be on MontiCore 5.3.0
     */
    symbol scope Component implements Element =
      Stereotype?
      (["interface"] | ["specification"])? (["component"] | ["application"])  Name
      head:ComponentHead
      (instanceName:Name actualTypeArgument:TypeArguments?)?
      body:ComponentBody;

    /* ============================================================ */
    /* ===================== Import Statements ==================== */
    /* ============================================================ */

    interface ImportStatement;

    /**
     * Imported CPP elements (data types, components etc)
     */
    CPPImportStatementLOCAL implements ImportStatement =
      "#include" cppImport:String;

    CPPImportStatementSYSTEM implements ImportStatement =
      "#include" "<" cppSystemImport:(Name& || ".")+ ">";

    /* ============================================================ */
    /* ================= Assumptions & Guarantees ================= */
    /* ============================================================ */

    Assumption implements Element = "assume" ":" guard:Expression ";";
    Guarantee implements Element = "guarantee" ":" guard:Expression ";";

    /* ============================================================ */
    /* ========================== Ports =========================== */
    /* ============================================================ */

    interface AllowedValues;

    Port implements Element =
        Stereotype?
        (incoming:["in"] | outgoing:["out"])    // direction
        Type ("(" AllowedValues ")" )?
        (MTPortDeclaration || ",")+;

    MTPortDeclaration = Name ("=" default:Valuation)?;

    //StreamHistoryValue implements Expression = "[" IntLiteral | "pre" "]";

    MTValueList   implements AllowedValues = (Valuation | MTValueRange) ("," (Valuation | MTValueRange))*;
    MTValueRange  implements AllowedValues = lowerBound:Valuation (":" stepsize:Valuation)? ":" upperBound:Valuation;
    MTValueFormat implements AllowedValues = "format" ":" format:String; // RegEx to which value has to conform


    /* ============================================================ */
    /* ====================== Resource Ports ====================== */
    /* ============================================================ */

    /**
     * Defines an interface of a component containing
     * incoming and outgoing ports to external resources.
     *
     * @attribute stereotype an optional stereotype
     * @attribute resourcePorts a list of ports that are contained in
     *   this interface
     */
    ResourceInterface implements Element =
      Stereotype?
      "resource" "port"
      resourcePort:(ResourcePort || ",")+ ";";

     /**
      * An incoming resource port is used to receive messages from external sources, an
      * outgoing resource port is used to send messages to external resources.
      *
      * @attribute stereotype an optional stereotype
      * @attribute incoming true, if this is an incoming port
      * @attribute outgoing true, if this is an outgoing port
      * @attribute type the message type of this port
      * @attribute name an optional name of this port
      * @attribute resourceoption optional configuration for the
      *    resource port
      * @attribute Parameters for the generated resource server
      */
    symbol ResourcePort =
      Stereotype?
      (incoming:["in"] | outgoing:["out"])
      Type Name ("("(
                   (
                     ((ResourceOption "," uri:String ) |
                     ResourceOption |
                     uri:String )
                     ("," (ResourceParameter || ",")+)?
                   ) |
                   ((ResourceParameter || ",")+)
                )
                ")")?
      ("requires" requiresType:Name ":" requiresName:StringLiteral)?  ;

    ResourceParameter = key:Name "=" value:String;

    /**
     * Optional settings for resource ports
     */
    enum ResourceOption =
      "netserver" | "netclient" | "ipcreqrep" |
      "ipclisten" | "fsappend" | "fsoverwrite";

    /* ============================================================ */
    /* ====================== Control Blocks ====================== */
    /* ============================================================ */

    /**
     * A Control Block consists of statements controlling the execution
     * behavior of the component. The described behavior in this block
     * only modifies the already existing behavior of the component
     * (hwc, automatons, etc) and thus does not implement the
     * BehaviorElement interface.
     */
    ControlBlock implements Element =
        "control" "{"
        ControlStatement*
        "}";

    interface ControlStatement;

    /**
     * The calculation interval specifies in which 
     * interval the component is executed.
     */
    CalculationInterval implements ControlStatement =
      "update" "interval" interval:IntLiteral TimeUnit";";

    enum TimeUnit = "msec" | "sec" | "min";

    /**
     * BatchStatements define which ports should be
     * handled in batch processing mode instead of
     * handling only one incoming message per tick
     */
    BatchStatement implements ControlStatement =
        "batch" batchPorts:(Name& || ",")+ ";";

    /** SyncStatements allow the specification of groups of ports
     * that should only be handled together
     */
    symbol SyncStatement implements ControlStatement =
        "sync" "port" "group" Name& "(" syncedPort:(Name || ",")* ")" ";";

    /* ============================================================ */
    /* ================ Requirements & Capabilities =============== */
    /* ============================================================ */

    /**
     *  RequirementStatements contain information about what physical requirements
     *  a component has. E.g Sensors/Actuators etc.
     */
    RequirementStatement implements Element =
      "requires" (propertiess:Property | "{" properties:Property+ "}");

    Property = Name& ":" 
      (
        stringValue:StringLiteral | booleanValue:BooleanLiteral |
        doubleValue:DoubleLiteral | integerValue:IntLiteral | 
        longValue:LongLiteral
      ) ";";

    /* ============================================================ */
    /* =================== If-Then-Else Behavior ================== */
    /* ============================================================ */

    /**
     * Executionblocks contain If and Else Statements that
     * control the behavior combined with handwritten code
     * functions.
     */
    ExecutionBlock implements BehaviorElement =
      "behavior" "{" ExecutionStatement* "}";

    interface ExecutionStatement;

    /**
     * IfStatements specify which function in the
     * handwritten implementation should be executed depending
     * on the presence on messages on incoming ports and
     * values of current messages.
     */
    ExecutionIfStatement implements ExecutionStatement =
        "if" (guard:GuardExpression) ":" method:Name&"()"
        ("|" ("prio" | "priority") "=" priority:IntLiteral)? ";";

    ExecutionElseStatement implements ExecutionStatement =
        "else" method:Name&"()" ";";

    /**
     * The Value for empty data
     * Copied from MontiArc. We dont actually need a different syntax but MontiArc's AST class
     * also specifies how to print NoData as "null" in the target language. For C++, we need to
     * overwrite this to write an empty optional.
     */
    NoData implements Expression = "--";
}
